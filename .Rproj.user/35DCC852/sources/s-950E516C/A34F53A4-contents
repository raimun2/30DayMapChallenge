library(tidyverse)
library(rgeos)
library(rgdal)
library(geosphere)

cerros_raw = read.table("data/cerros_unicos.csv", sep=";", dec=",", header = T)
cerros = cerros_raw

segs     <- read_rds("data/raster_segs.rds")
manzanas <- read_rds("data/raster_manzanas.rda")
#### cargo mancha urbana de santiago
shaperaw = readOGR(dsn = "data/GS/.", layer = "shapeGS")

prj_dd = "+proj=longlat +ellps=WGS84 +datum=WGS84  +no_defs"

   # defino proyeccion para proyecto
shape = spTransform(shaperaw,prj_dd)

######## 
###### calculo distancias a las cimas desde cada manzana, 
###### excluyo poligonos con distancias a cimas menores a percentil 5%
###### heuristica, deberia corregir con inspeccion manual
puntos_espaciales <- SpatialPoints(cerros[, 3:4], proj4string = CRS(prj_dd))

puntos_poly <- gCentroid(shape, byid=TRUE)

distancias <-   distm(puntos_poly,puntos_espaciales,  fun = distHaversine)

minimus = apply(distancias, 1, min) / 1000 ## 111 kilometros por cada degree

hist(minimus)


shape$Distancia_minima = minimus 

data_hist <- shape@data[,c("Distancia_minima", "NUMP")]

data_hist <- data_hist[!is.na(data_hist$NUMP),]

write_rds(data_hist, "data/analisis_hist.rds")


# shape.points = fortify(poligonos_nocerros, region = "CODINE11")
# colores = shape@data[,c("CODINE11", "Distancia_minima")]
# shape.points = merge(shape.points, colores, by.x="id", by.y="CODINE11")
# 

ext         <- floor(extent(shape))
raster_base <- raster(ext, res= 0.0002)
raster_manzanas <- rasterize(shape, raster_base, field = 'Distancia_minima', fun = "min")
crs(raster_manzanas) = sp::CRS(prj_dd)

write_rds(raster_manzanas, "data/raster_manzanas.Rda")



###### ANALISIS 
datos = poligonos_nocerros@data
datos$min_dist = datos$Distancia_minima
datos$cluster = floor(datos$min_dist)


res = cbind(as.data.frame(round(100*cumsum(aggregate(NUMP~cluster,data=datos,sum)$NUMP) / 
                                  sum(aggregate(NUMP~cluster, data=datos, sum)$NUMP)
                                ,1)), 
            aggregate(NUMP~cluster,data=datos,sum)$cluster)

colnames(res) =c("cum_perc","radio")


res$radio = (1+res$radio)
write_rds(res, file = "data/analysis.rds")

raster_segs <- read_rds(file = "data/raster_segs.rds")
#





#### leaflet




# http://leaflet-extras.github.io/leaflet-providers/preview/



# %>% #grafico cumbres andes azul
#   addCircleMarkers(data = ruta_1$rutasp, radius = 1, col = rainbow(8)[1], group="Ruta 1") %>% 
#   addCircleMarkers(data = ruta_2$rutasp, radius = 1, col = rainbow(8)[2], group="Ruta 2") %>% 
#   addCircleMarkers(data = ruta_4$rutasp, radius = 1, col = rainbow(8)[4], group="Ruta 4") %>% 
#   addCircleMarkers(data = ruta_5$rutasp, radius = 1, col = rainbow(8)[5], group="Ruta 5") %>% 
#   addCircleMarkers(data = ruta_6$rutasp, radius = 1, col = rainbow(8)[6], group="Ruta 6") %>% 
#   addCircleMarkers(data = ruta_7$rutasp, radius = 1, col = rainbow(8)[7], group="Ruta 7") %>% 
#   addCircleMarkers(data = ruta_matt$rutasp, radius = 1, col = rainbow(8)[8], group="Ruta Matt") %>% 
#   addLayersControl(
#     overlayGroups =c("Cumbres AAR", "Ruta Matt", "Ruta 1", "Ruta 2", "Ruta 3", "Ruta 4", "Ruta 5", "Ruta 6", "Ruta 7"),
#     options = layersControlOptions(collapsed=FALSE)
#   )

# 

g <- ggplot(res, aes(radio))

# Number of cars in each class:
g + geom_bar(aes(weight = cum_perc,fill = cum_perc))+ 
  scale_fill_gradientn(colours = terrain.colors(3))





###### OBTENGO ELEVACIONES DENTRO DE ESA AREA #####

# #### obtengo elevaciones raster
# elev = get_elev_raster(shape, prj = prj_dd, z = 13)
# 
# #### paso el objeto raster a contornos (curvas de nivel)
# curvas_nivel = rasterToContour(elev,nlevels = 9)
# 
# #### convierto curvas de nivel en data frame (para graficar con ggplot)
# 
# puntos_contorno = do.call(rbind, lapply(curvas_nivel$level, 
#                                         function (y) do.call(rbind,lapply( 
#                                           coordinates(curvas_nivel[curvas_nivel$level==y,])[[1]]  ,
#                                           function(x) data.frame(level=y,x)))))
# 
# linea_contorno = do.call(rbind, lapply(curvas_nivel$level, 
#                                        function (y) do.call(rbind,lapply( 
#                                          coordinates(curvas_nivel[curvas_nivel$level==y,])[[1]]  ,
#                                          function(x) nrow(data.frame(level=y,x))))))
# 
# 
# 
# colnames(puntos_contorno) = c("ele","lng","lat")
# puntos_contorno$ele = as.numeric(as.character(puntos_contorno$ele))
# 
# puntos_contorno$linea = rep(1:nrow(linea_contorno),linea_contorno)

###################################################
# ####
# maptype = 'terrain'
# map = suppressWarnings(suppressMessages(ggmap::get_map(bboxexp, maptype = maptype, zoom=13, source="google")))
# 
# 
# ggmap(map) + 
#   geom_point(data=segs,shape=".",col="yellow",aes(lng,lat)) +
#   geom_polygon(data=shape.points,aes(long,lat,group=group,fill=Distancia_minima),color=NA,alpha=0.7) +
#   scale_fill_gradientn(colours = terrain.colors(3)) + 
#   geom_path(data=puntos_contorno,  aes(lng,lat, group=linea),col="red") +
#   geom_point(data=cerros,shape=17,col="darkgreen",aes(lng,lat),size=4) + 
#   labs(title = "Acceso a la MontaÃ±a #runtothehills", size=2,
#        subtitle = "Distancia (km) de cada manzana al cerro mas cercano", 
#        caption = "Fuentes: \n Stamen (mapa) \n SRTM (curvas de nivel) \n Wikiexplora, Andeshandbook, Strava (trayectorias cerros) \n  Tageo, Wikipedia, Geonames (coordenadas cumbres) \n 
#        Autor: Raimundo Sanchez, PhD")

###### analisis



